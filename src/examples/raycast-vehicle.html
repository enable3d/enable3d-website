<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Raycast Vehicle</title>
    <link rel="stylesheet" href="/css/examples.css?ver=1.0.0" />
    <script src="/js/examples.js?ver=1.1.1"></script>
    <script src="/lib/enable3d/enable3d.framework.0.25.1.min.js"></script>
  </head>

  <body>
    <div id="info-text">Car using Raycast Vehicle<br />WASD and SPACE</div>
    <script>
      const { Project, Scene3D, PhysicsLoader, THREE } = ENABLE3D

      // https://github.com/kripken/ammo.js/blob/master/examples/webgl_demo_vehicle/index.html
      class Vehicle {
        vehicle
        tuning

        wheelMeshes = []

        engineForce = 0
        vehicleSteering = 0
        breakingForce = 0

        constructor(scene, physics, chassis, wheelMesh) {
          this.scene = scene
          this.physics = physics
          this.chassis = chassis
          this.wheelMesh = wheelMesh

          const { physicsWorld } = physics

          this.tuning = new Ammo.btVehicleTuning()
          const rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld)
          this.vehicle = new Ammo.btRaycastVehicle(this.tuning, chassis.body.ammo, rayCaster)

          // do not automatically sync the mesh to the physics body
          chassis.body.skipUpdate = true

          this.vehicle.setCoordinateSystem(0, 1, 2)
          physicsWorld.addAction(this.vehicle)

          const FRONT_LEFT = 0
          const FRONT_RIGHT = 1
          const BACK_LEFT = 2
          const BACK_RIGHT = 3

          const wheelAxisPositionBack = -1.3
          const wheelRadiusBack = 0.4
          const wheelHalfTrackBack = 1.1
          const wheelAxisHeightBack = 0

          const wheelAxisFrontPosition = 1.2
          const wheelRadiusFront = 0.4
          const wheelHalfTrackFront = 1.1
          const wheelAxisHeightFront = 0

          this.addWheel(
            true,
            new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition),
            wheelRadiusFront,
            FRONT_LEFT
          )
          this.addWheel(
            true,
            new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition),
            wheelRadiusFront,
            FRONT_RIGHT
          )
          this.addWheel(
            false,
            new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack),
            wheelRadiusBack,
            BACK_LEFT
          )
          this.addWheel(
            false,
            new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack),
            wheelRadiusBack,
            BACK_RIGHT
          )
        }

        update() {
          let tm, p, q, i
          const n = this.vehicle.getNumWheels()
          for (i = 0; i < n; i++) {
            // this.vehicle.updateWheelTransform(i, true)
            tm = this.vehicle.getWheelTransformWS(i)
            p = tm.getOrigin()
            q = tm.getRotation()
            this.wheelMeshes[i].position.set(p.x(), p.y(), p.z())
            this.wheelMeshes[i].quaternion.set(q.x(), q.y(), q.z(), q.w())
            // this.wheelMeshes[i].rotateZ(Math.PI / 2)
          }

          tm = this.vehicle.getChassisWorldTransform()
          p = tm.getOrigin()
          q = tm.getRotation()

          this.chassis.position.set(p.x(), p.y(), p.z())
          this.chassis.quaternion.set(q.x(), q.y(), q.z(), q.w())
        }

        addWheel(isFront, pos, radius, index) {
          var suspensionStiffness = 50.0
          var suspensionDamping = 2.3
          var suspensionCompression = 4.4
          var suspensionRestLength = 0

          const friction = 50
          const rollInfluence = 0.01

          const wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0)
          const wheelAxleCS = new Ammo.btVector3(-1, 0, 0)

          const wheelInfo = this.vehicle.addWheel(
            pos,
            wheelDirectionCS0,
            wheelAxleCS,
            suspensionRestLength,
            radius,
            this.tuning,
            isFront
          )

          wheelInfo.set_m_suspensionStiffness(suspensionStiffness)
          wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping)
          wheelInfo.set_m_wheelsDampingCompression(suspensionCompression)

          wheelInfo.set_m_frictionSlip(friction)
          wheelInfo.set_m_rollInfluence(rollInfluence)

          this.wheelMeshes[index] = this.wheelMesh.clone(true)
          this.scene.add(this.wheelMeshes[index])
        }
      }

      class MainScene extends Scene3D {
        car
        keys = {
          w: false,
          a: false,
          s: false,
          d: false,
          space: false
        }
        vehicleSteering = 0
        light

        async create() {
          //this.physics.debug?.enable()

          const { lights } = await this.warpSpeed('-ground')

          if (lights) {
            this.light = lights.directionalLight
            const d = 4
            this.light.shadow.camera.top = d
            this.light.shadow.camera.bottom = -d
            this.light.shadow.camera.left = -d
            this.light.shadow.camera.right = d

            this.light.shadow.mapSize.set(2048, 2048)

            this.light.shadow.camera.near = 200
            this.light.shadow.camera.far = 240

            // https://stackoverflow.com/a/48939256
            this.light.shadow.bias = -0.01

            // debug shadow
            const shadowHelper = new THREE.CameraHelper(this.light.shadow.camera)
            this.scene.add(shadowHelper)
          }

          this.camera.position.set(5, 10, -20)
          this.camera.lookAt(0, 0, 0)
          // this.physics.debug?.enable()

          const grass = await this.load.texture('/assets/img/grass.jpg')
          const grassGround = grass.clone()
          grassGround.needsUpdate = true
          grassGround.wrapS = grassGround.wrapT = 1000 // RepeatWrapping
          grassGround.offset.set(0, 0)
          grassGround.repeat.set(10, 10)

          this.physics.add.ground({ y: -1, width: 100, height: 100 }, { lambert: { map: grassGround } })

          const ramp = this.add.box({ width: 5, height: 10, z: -20 }, { lambert: { map: grass } })
          ramp.rotateX(-Math.PI / 3)
          this.physics.add.existing(ramp, { collisionFlags: 1, mass: 0 })

          const gltf = await this.load.gltf('/assets/glb/car.glb')
          const scene = gltf.scenes[0]

          let chassis
          let tire

          scene.traverse(child => {
            if (child.isMesh) {
              if (/window/gi.test(child.name)) {
                child.material.transparent = true
                child.material.opacity = 0.5
              } else if (child.name === 'Chassis') {
                chassis = child
                chassis.receiveShadow = chassis.castShadow = true
              } else if (child.name === 'Tire') {
                tire = child
                tire.receiveShadow = tire.castShadow = true
                tire.geometry.center()
              }
            }
          })
          // this.add.existing(gltf.scenes[0])

          if (!chassis || !tire) return

          this.add.existing(chassis)
          this.physics.add.existing(chassis, { shape: 'convex', mass: 1200 })

          // chassis = this.physics.add.box(
          //   { depth: 3, height: 0.8, width: 1.75, mass: 1200 },
          //   { lambert: { color: 'red' } }
          // )

          // tire = this.make.cylinder(
          //   {
          //     radiusBottom: 0.4,
          //     radiusTop: 0.4,
          //     height: 0.2,
          //     radiusSegments: 12
          //   },
          //   { lambert: { color: 'black' } }
          // )

          chassis.add(this.camera)

          this.car = new Vehicle(this.scene, this.physics, chassis, tire)

          // keys
          const keyEvent = (e, down) => {
            switch (e.code) {
              case 'KeyW':
                this.keys.w = down
                break
              case 'KeyA':
                this.keys.a = down
                break
              case 'KeyS':
                this.keys.s = down
                break
              case 'KeyD':
                this.keys.d = down
                break
              case 'Space':
                this.keys.space = down
                break
            }
          }
          document.addEventListener('keydown', e => keyEvent(e, true))
          document.addEventListener('keyup', e => keyEvent(e, false))
        }

        update() {
          // adjust shadow
          this.light.position.x = this.car.chassis.position.x
          this.light.position.y = this.car.chassis.position.y + 200
          this.light.position.z = this.car.chassis.position.z + 100
          this.light.target = this.car.chassis

          const FRONT_LEFT = 0
          const FRONT_RIGHT = 1
          const BACK_LEFT = 2
          const BACK_RIGHT = 3

          let engineForce = 0
          let breakingForce = 0
          const steeringIncrement = 0.04
          const steeringClamp = 0.3
          const maxEngineForce = 5000
          const maxBreakingForce = 100

          const speed = this.car.vehicle.getCurrentSpeedKmHour()

          this.camera.lookAt(this.car.chassis.position.clone())

          // front/back
          if (this.keys.w) engineForce = maxEngineForce
          else if (this.keys.s) engineForce = -maxEngineForce
          else engineForce = 0

          // left/right
          if (this.keys.a) {
            if (this.vehicleSteering < steeringClamp) this.vehicleSteering += steeringIncrement
          } else if (this.keys.d) {
            if (this.vehicleSteering > -steeringClamp) this.vehicleSteering -= steeringIncrement
          } else {
            if (this.vehicleSteering > 0) this.vehicleSteering -= steeringIncrement / 2
            if (this.vehicleSteering < 0) this.vehicleSteering += steeringIncrement / 2
            if (Math.abs(this.vehicleSteering) <= steeringIncrement) this.vehicleSteering = 0
          }

          // break
          if (this.keys.space) breakingForce = maxBreakingForce
          else breakingForce = 0

          this.car.vehicle.applyEngineForce(engineForce, BACK_LEFT)
          this.car.vehicle.applyEngineForce(engineForce, BACK_RIGHT)

          this.car.vehicle.setSteeringValue(this.vehicleSteering, FRONT_LEFT)
          this.car.vehicle.setSteeringValue(this.vehicleSteering, FRONT_RIGHT)

          this.car.vehicle.setBrake(breakingForce / 2, FRONT_LEFT)
          this.car.vehicle.setBrake(breakingForce / 2, FRONT_RIGHT)
          this.car.vehicle.setBrake(breakingForce, BACK_LEFT)
          this.car.vehicle.setBrake(breakingForce, BACK_RIGHT)

          this.car.update()
        }
      }

      PhysicsLoader('/lib/ammo/kripken', () => new Project({ scenes: [MainScene], antialias: true }))
    </script>
  </body>
</html>
